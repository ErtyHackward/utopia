//--------------------------------------------------------------------------------------
// Constant Buffer Variables
//--------------------------------------------------------------------------------------

cbuffer PerDraw
{
	matrix World;
};

cbuffer PerFrame
{
	matrix ViewProjection;
	matrix LightViewProj;
	//float fogDensity = 0.06f;
	float3 SunColor = { 0.1, 0.1, 0.1 };			  // Diffuse lighting color
	float dayTime;
};

#define E 2.71828

static const float texmul1[6] = { -1,  1, -1,  1,  0,  0};
static const float texmul2[6] = {  0,  0,  0,  0, -1,  1};
static const float texmul3[6] = { -1, -1,  0,  0, -1, -1};
static const float texmul4[6] = {  0,  0,  1,  1,  0,  0};

static const float SHADOW_EPSILON = 0.001f;

//--------------------------------------------------------------------------------------
// Texture Samplers
//--------------------------------------------------------------------------------------
Texture2DArray TerraTexture;
SamplerState SamplerDiffuse
{
	Filter = MIN_LINEAR_MAG_POINT_MIP_LINEAR;
	AddressU = Wrap ; 
	AddressV = Wrap ;
};

Texture2D FogTexture;
SamplerState SamplerFog
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Wrap ; 
	AddressV = Wrap ;
};

//Texture2D ShadowMap;
//SamplerState SamplerShaddow
//{
//	Filter = MIN_MAG_MIP_POINT;
//	AddressU = CLAMP ; 
//	AddressV = CLAMP ;
//};

//--------------------------------------------------------------------------------------
//Vertex shader Input
struct VS_IN
{
	uint4 Position		 : POSITION;
	float4 Col			 : COLOR;
	float2 VertexInfo	 : INFO;
};

//Pixel shader Input for shadow creation
struct PS_IN_SHADOW
{
    float4 Position  : SV_POSITION;
    float3 UVW       : TEXCOORD0;
};

struct PS_IN
{
	float4 Position				: SV_POSITION;
	float3 UVW					: TEXCOORD0;
	//float fogDist				: VARIOUS0;
	float3 EmissiveLight		: Light0;
};

//--------------------------------------------------------------------------------------
// Fonctions
//--------------------------------------------------------------------------------------
//
// Calculates fog factor based upon distance
//
float CalcFogFactor( float d )
{
	float dCleanZone = d - 210;
	d = clamp(dCleanZone, 0, d);

    float fogCoeff;
    
	//fogCoeff = 1.0 / pow( E, d*fogDensity );
    fogCoeff = 1.0 / pow( E, d*d*fogDensity*fogDensity );
   
    return clamp( fogCoeff, 0, 1 );
}

// ============================================================================
// Shadow Map Creation ==> not used ATM moment, stability problems, and too much impact on the GPU ! (Need to render the scene twice !)
// ============================================================================
// float CalcShadowFactor(float4 projTexC)
// {
// 	// Complete projection by doing division by w.
// 	projTexC.xyz /= projTexC.w;
// 	
// 	// Transform from NDC space to texture space.
// 	projTexC.x = +0.5f*projTexC.x + 0.5f;
// 	projTexC.y = -0.5f*projTexC.y + 0.5f;
// 	
// 	// Depth in NDC space.
// 	float depth = projTexC.z;
// 	
// 	// Sample shadow map to get nearest depth to light.
// 	float s0 = ShadowMap.Sample(SamplerShaddow, projTexC.xy).r;
// 		
// 	// Is the pixel depth <= shadow map value?
// 	float result0 = depth <= s0 + SHADOW_EPSILON;
// 
// 	// Interpolate results.
// 	return result0;
// }

PS_IN_SHADOW VS_SHADOW(VS_IN input)
{
    PS_IN_SHADOW Out;

	float4 newPosition = {input.Position.xyz, 1.0f};
	newPosition.y += input.VertexInfo.x; //Offseting the Y

	Out.Position = mul(newPosition, mul(World, LightViewProj));

	int facetype = input.VertexInfo.y;
	//Compute the texture mapping
	Out.UVW = float3(
						(input.Position.x * texmul1[facetype]) + (input.Position.z * texmul2[facetype]), 
						(input.Position.y * texmul3[facetype]) + (input.Position.z * texmul4[facetype]),
						input.Position.w );

    return Out;
}



//--------------------------------------------------------------------------------------
// Vertex Shaders
//--------------------------------------------------------------------------------------

PS_IN VS(VS_IN input)
{
    PS_IN output;
	
	float4 newPosition = {input.Position.xyz, 1.0f};
	newPosition.y += input.VertexInfo.x; //Offseting the Y

    float4 worldPosition = mul(newPosition, World);
	output.Position = mul(worldPosition, ViewProjection);

	int facetype = input.VertexInfo.y;
	//Compute the texture mapping
	output.UVW = float3(
						(input.Position.x * texmul1[facetype]) + (input.Position.z * texmul2[facetype]), 
						(input.Position.y * texmul3[facetype]) + (input.Position.z * texmul4[facetype]),
						input.Position.w );

	//output.fogDist = length(worldPosition.xyz);

	output.EmissiveLight = saturate(input.Col.rgb +  SunColor * input.Col.a);

    return output;
}

//--------------------------------------------------------------------------------------
// Pixel Shader
//--------------------------------------------------------------------------------------
float4 PS(PS_IN input) : SV_Target
{
	//calculate the fog factor
	//float fog = CalcFogFactor(input.fogDist);

	float4 color = TerraTexture.Sample(SamplerDiffuse, input.UVW) * float4(input.EmissiveLight, 1);
	//float4 FogColor = FogTexture.Sample(SamplerFog, dayTime);

	//Add AmbianColor
	float4 colorwithLighting = color;

	// Apply fog on output color
	//colorwithLighting = fog * colorwithLighting + (1.0 - fog) * FogColor;

    return colorwithLighting;
}

//--------------------------------------------------------------------------------------
technique11 Render
{
	//Normal Pass
	pass P0
	{
		SetVertexShader( CompileShader( vs_4_0, VS() ) );
		SetGeometryShader( 0 );
		SetPixelShader( CompileShader( ps_4_0, PS() ) );
	}
}

technique11 CreateShadowMap
{
	//Normal Pass
	pass P0
	{
		SetVertexShader( CompileShader( vs_4_0, VS_SHADOW() ) );
		SetGeometryShader( 0 );
		SetPixelShader( 0 );
	}
}